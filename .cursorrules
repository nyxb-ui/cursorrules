You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI and Tailwind.

Project Structure
----------------
- Next.js app using App Router
- Source code lives in `src/`
- Components organization:
  - Shadcn components go in `components/ui/`
  - All other components go in `components/`
  - Colocate components with their feature unless they're reused across features
- Server actions live in `src/actions/`
- Use kebab-case for:
  - Route directories (e.g., `api/hello-world/route`) 
  - Component files (e.g., `components/nice-button.tsx`)

Coding Style
-----------
- Write concise, technical TypeScript code
- Use functional and declarative patterns; avoid classes
- Prefer iteration and modularization over duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure files: exports, subcomponents, helpers, types, static content
- Favor named exports for components
- Use TypeScript for all code with proper type imports:
  ```ts
  import type { Action } from "@prisma/client";
  import { type Action, GroupItemType } from "@prisma/client"; 
  ```

Components & UI
-------------
- Use Shadcn UI components and Tailwind for styling
- Implement mobile-first responsive design with Tailwind
- Use `next/image` for images
- Use the LoadingContent component for async states:
  ```tsx
  <Card>
    <LoadingContent loading={isLoading} error={error}>
      {data && <MyComponent data={data} />}
    </LoadingContent>
  </Card>
  ```

Data Fetching
------------
- Use SWR for GET requests:
  ```ts
  const { data, isLoading, error } = useSWR<ResponseType>(
    `/api/endpoint?param=${value}`
  );
  ```
- Use Next.js server actions for mutations
- Server actions must:
  - Return Promise<ServerActionResponse>
  - Use Zod for validation
  - Handle errors gracefully
  - Follow this format:
  ```ts
  export const myAction = withActionInstrumentation(
    "actionName",
    async (unsafeData: InputType) => {
      const session = await auth();
      if (!session?.user.id) return { error: "Not logged in" };

      const { data, success, error } = inputSchema.safeParse(unsafeData);
      if (!success) return { error: error.message };

      // Action logic here
      
      revalidatePath("/some-path");
    }
  );
  ```

Forms
-----
- Use React Hook Form with Zod validation
- Validate on both client and server
- Handle errors with toasts:
  ```ts
  if (isActionError(result)) {
    toastError({
      title: "Error",
      description: result.error
    });
  } else {
    toastSuccess({ description: "Success!" });
  }
  ```
- For textareas use:
  ```tsx
  <Input
    type="text"
    autosizeTextarea
    rows={3}
    registerProps={register("fieldName")}
    error={errors.fieldName}
  />
  ```

Logging
-------
Use scoped logger:
```ts
import { createScopedLogger } from "@/utils/logger";
const logger = createScopedLogger("ScopeName");
logger.log("Message", { data });
```
